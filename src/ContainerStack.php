<?php

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

namespace Laasti\Stack;

use League\Container\ContainerInterface;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

/**
 * Description of Stack
 *
 * @author Sonia
 */
class ContainerStack implements StackInterface
{

    /**
     * Contains the registered middlewares
     * @var array
     */
    protected $middlewares = [];

    /**
     * Contains the registered terminable middlewares
     * @var array
     */
    protected $terminableMiddlewares = [];
    
    /**
     * DI container
     * @var ContainerInterface 
     */
    protected $container;
    
    public function __construct(ContainerInterface $container)
    {
        $this->container = $container;
    }

    /**
     * Adds the middleware at the beginning.
     * You can pass additional arguments to the method. They will be used when calling handle/close methods.
     *
     * @param MiddlewareInterface $middleware
     * @return SimpleStack
     */
    public function unshift($middleware)
    {
        array_unshift($this->middlewares, func_get_args());

        return $this;
    }

    //TODO: Should it be permitted for a terminate only middleware to be added?
    //Maybe it would be better to have a middleware that calls those terminate only objects
    /**
     * Adds the middleware at the end.
     * You can pass additional arguments to the method. They will be used when calling handle/close methods.
     *
     * @param MiddlewareInterface $middleware
     * @return SimpleStack
     */
    public function push($middleware)
    {
        array_push($this->middlewares, func_get_args());

        return $this;
    }

    /**
     * Loops through all registered middlewares until a response is returned.
     *
     * @throws StackException When no response is returned
     * @param Request $request
     * @return Response
     */
    public function execute(Request $request)
    {
        $response = null;
        foreach ($this->middlewares as $key => $spec) {
            //Get the middleware
            $middleware = $this->container->get(array_shift($spec));
            
            if (!$middleware instanceof MiddlewareInterface) {
                throw new \InvalidArgumentException('The middlewares must be an instance of MiddlewareInterface.');
            }
            
            if ($middleware instanceof MiddlewareTerminableInterface) {
                array_push($this->terminableMiddlewares, array_merge(array($middleware), $spec));
            }
            
            //Response was continue the loop to register the remaining TerminableMiddleware
            if (!is_null($response)) {
                continue;
            }
            
            //Put request as first parameter for the middleware
            array_unshift($spec, $request);
            

            $return = call_user_func_array([$middleware, 'handle'], $spec);

            if ($return instanceof Response) {
                $response = $return;
            }
        }

        if (is_null($response)) {
            throw new StackException('No response generated by the middleware stack.');
        }
        
        return $response;
    }

    /**
     * Loops through all TerminableMiddleware
     *
     * @param Request $request
     * @param Response $response
     */
    public function close(Request $request, Response $response)
    {

        $inverted = array_reverse($this->terminableMiddlewares);

        foreach ($inverted as $spec) {
            $middleware = array_shift($spec);

            $args = array_merge(array($request, $response), $spec);

            call_user_func_array([$middleware, 'terminate'], $args);
        }
    }

}
