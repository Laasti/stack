<?php

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

namespace Laasti\Stack;

use Laasti\Stack\MiddlewareInterface;
use Laasti\Stack\MiddlewareTerminableInterface;
use Laasti\Stack\StackInterface;
use ReflectionClass;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

/**
 * Description of Stack
 *
 * @author Sonia
 */
class Stack implements StackInterface
{

    const TERMINABLE_INTERFACE = "Laasti\Stack\MiddlewareTerminableInterface";

    protected $middlewares = [];

    public function unshift(MiddlewareInterface $obj)
    {
        array_unshift($this->middlewares, func_get_args());
        return $this;
    }

    //TODO: Should it be permitted for a terminate only middleware to be added?
    //Maybe it would be better to have a middleware that calls those terminate only objects
    public function push(MiddlewareInterface $obj)
    {
        array_push($this->middlewares, func_get_args());
        return $this;
    }

    /**
     *
     * @param Request $request
     * @return Response
     */
    public function execute(Request $request)
    {

        foreach ($this->middlewares as $key => $spec) {
            $class = array_shift($spec);
            if (is_object($class)) {
                $middleware = $class;
            } else {
                $middleware = new $class;
            }
            array_unshift($spec, $request);
            $return = call_user_func_array([$middleware, 'handle'], $spec);

            //Save for terminate request if terminableInterface
            if (!$middleware instanceof MiddlewareTerminableInterface) {
                unset($this->middlewares[$key]);
            } else {
                $this->middlewares[$key] = $middleware;
            }

            if ($return instanceof Request) {
                continue;
            } elseif ($return instanceof Response) {
                return $return;
            }
        }

        throw new StackException('No response generated by the middleware stack.');
    }

    public function close(Request $request, Response $response)
    {

        $inverted = array_reverse($this->middlewares);

        foreach ($inverted as $spec) {
            //Middleware already instantiated
            if (is_object($spec)) {
                $middleware = $spec;
            } else {
                //TODO: This code is shaky
                $classname = array_shift($spec);
                if (is_object($classname)) {
                    $middleware = $classname;
                } else {
                    $class = new ReflectionClass($classname);
                    echo $classname;
                    if ($class->implementsInterface(self::TERMINABLE_INTERFACE)) {
                        $middleware = $class->newInstance();
                    } else {
                        continue;
                    }
                }
            }

            call_user_func_array([$middleware, 'terminate'], array($request, $response));
        }
    }

}
